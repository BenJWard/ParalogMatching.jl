{
    "docs": [
        {
            "location": "/", 
            "text": "ParalogMatching.jl documentation\n\n\n\n\nIntroduction\n\n\nThis package implements the paralog matching technique presented in the paper \n\"Simultaneous identification of specifically interacting paralogs and interprotein contacts by Direct Coupling Analysis\"\n by Thomas Gueudr\u00e9, Carlo Baldassi, Marco Zamparo, Martin Weigt and Andrea Pagnani, Proc. Natl. Acad. Sci. U.S.A. 201607570 (2016), \ndoi:10.1073/pnas.1607570113\n\n\nThe main idea of the method is to perform a statistical analysis of two given multiple sequence alignments, each containing one protein family. Each familiy should comprise several species, and each species may have several sequences belonging to the family. The algorithm tries to associate (match) interacting partners from the two families within each species.\n\n\nThe underlying main assumption is that the proper matching is the one maximizing the co-evolution signal. Such maximization is performed over the Bayesian inference of a Gaussian model, by inverting the correlation matrix.\n\n\nThe code is written in \nJulia\n, and the functions are called from within Julia. However, a \ncommand-line interface\n is also provided for those unfamiliar with the language.\n\n\nThe current code was tested on Julia versions 0.4 and 0.5.\n\n\n\n\nInstallation\n\n\nTo install the module, use this command from within Julia:\n\n\njulia\n Pkg.clone(\nhttps://github.com/Mirmu/ParalogMatching.jl\n)\n\n\n\n\nDependencies will be installed automatically.\n\n\nHowever, you will also need to install at least one linear programming solver supported by \nMathProgBase\n. See the list of available solvers at the \nJuliaOpt page\n. Note that the solver efficiency is not particularly important for paralog matching, whose computational time is dominated by matrix inversion operations, therefore you don't need a particularly fast solver. If unsure, use \nPkg.add(\"Clp\")\n or \nPkg.add(\"GLPKMathProgInterface\")\n, which are free and open-source solvers.\n\n\n\n\nUsage\n\n\nThe module is loaded as any other Julia module:\n\n\njulia\n using ParalogMatching\n\n\n\n\nThe module provides a \nhigh-level interface\n, with one function which performs all operations and writes a file in output, and the \nlow-level interface\n functions which perform the single steps of the algorithm.\n\n\nA typical run of the algorithm could look like this:\n\n\njulia\n TrpAB, match = paralog_matching(\nTrpA.fasta\n, \nTrpB.fasta\n, \nMatch_TrpAB.fasta.gz\n, batch=5);\n\n\n\n\n\n\nHigh-level interface\n\n\n#\n\n\nParalogMatching.paralog_matching\n \n \nFunction\n.\n\n\nparalog_matching(infile1::AbstractString, infile2::AbstractString, outfile::AbstractString;\n         cutoff = 500,\n         batch = 1,\n         strategy = \ncovariation\n,\n         lpsolver = nothing)\n\n\n\n\nThis function performs the paralog matching from two given FASTA files containing the alignments for two different protein families. When the matching is done, it writes the result in a new FASTA file, in which each sequence is the concatenation of two mathing sequences in the original file.\n\n\nThe input format is standard FASTA, but the headers are parsed as explained in \nprepare_alignments\n.\n\n\nThe output file format is documented in \nwrite_fasta_match\n.\n\n\nThe keyword arguments are documented in \nprepare_alignments\n and \nrun_matching\n.\n\n\nBesides writing the \noutfile\n, this function also returns two values: the harmonized alignment (produced by \nprepare_alignments\n) and the resulting match (as returned by \nrun_matching\n).\n\n\nsource\n\n\n\n\nLow-level interface\n\n\nThe low-level interface functions are called by \nparalog_matching\n in the order in which they are documented here, but they can be called individually in order to inspect/manipulate the intermediate results if desired.\n\n\n#\n\n\nParalogMatching.read_fasta_alignment\n \n \nFunction\n.\n\n\nread_fasta_alignment(filename, max_gap_fraction=1.0; header_regex=nothing)\n\n\n\n\nParse a (possibly gzipped) FASTA file, converting it into an alignment which can be used in the Gaussian model used by ParalogMatching. Optionally, discards the sequences which have more than a fraction \nmax_gap_fraction\n of missing values (gaps) in the alignment.\n\n\nThe function automatically tries to parse the species names and the Uniprot ID, using a standard format specification. The species names are then used in the matching procedure; the Uniprot IDs are only used for writing the output files.\n\n\nYou can parse arbitrary files by providing a custom \nheader_regex\n (see also the \nJulia regex documentation\n). In its simples form, it needs to have at least two capture groups, the first one returning the Uniprot ID and the second the species name (additional capture groups are ignored). For example, if the headers in your FASTA file look like this:\n\n\nSOMELOCATION/SOMESPECIES/OTHERINFO\n\n\n\n\nthen you can use a regex like this one: \nread_fasta_alignment(..., header_regex=r\"^([^/]+)/([^/]+)/\")\n, i.e. line start, anything except a slash (captured), followed by a slash, then anything except a slash (captured), then a slash \u2014 the remainder of the line is then simply ignored. In more complicated cases (e.g. if the UniprotID and the species name are out of order), you can use named capture groups: in this case the \nheader_regex\n needs to contain both an \nid\n group and a \nspecies\n group (all additional groups are ignored). For example, if the headers in your FASTA file look like this:\n\n\nSOMESPECIES/OTHERINFO/SOMELOCATION\n\n\n\n\nthen you can use a regex like this one: \nheader_regex=r\"^(?\nspecies\n[^/]+)/([^/]+)/(?\nid\n.+)\"\n, i.e. line start, anything except a slash (capture as the species name), followed by a slash, then anything except a slash (captured but ignored), followed by a slash, then the rest of the line (captured as the ID).\n\n\nsource\n\n\n#\n\n\nParalogMatching.prepare_alignments\n \n \nFunction\n.\n\n\nprepare_alignments(X1::Alignment, X2::Alignment; cutoff::Integer = 500)\n\n\n\n\nPrepares two alignments (as returned by \nread_fasta_alignment\n) and returns a \nHarmonizedAlignments\n object. This object contains two filtered version of the original alignments, in which only the sequences belonging to species which exist in both alignments are kept, and which is ready to be passed to \nrun_matching\n.\n\n\nThe \ncutoff\n keyword argument can be used to discard all species for which there are more than a certain number of sequences in either alignment. Use \n0\n to disable this filter entirely.\n\n\nsource\n\n\n#\n\n\nParalogMatching.run_matching\n \n \nFunction\n.\n\n\nrun_matching(X12::HarmonizedAlignments;\n     batch = 1,\n     strategy = \ncovariation\n,\n     lpsolver = nothing)\n\n\n\n\nReturns the matching of the two alignments contained in \nX12\n, which need to be obtained by \nprepare_alignments\n. The returned matching is a Vector in which the entry \ni\n determines which sequence of the second alignment is the partner to sequence \ni\n in the first alignment.\n\n\nThe keywords are:\n\n\n\n\nbatch\n: how many species should be matched before updating the underlying model; smaller values give          better results but increase the computational time\n\n\nstrategy\n: the strategy to use when computing the matching. See below.\n\n\npseudo_count\n: gives the amount of regularization used for the inversion of the correlation matrix.                 A defaut of 0.5 gives sensible results, its value cannot be above 1.0.\n\n\nlpsolver\n: linear programming solver used when performing the matching with the \n\"covariation\"\n strategy.\n\n\n\n\n      The default (`nothing`) uses the default solver as detected automatically by `MathProgBase`.\n      You can override this by passing e.g. `lpsolver = GurobiSolver(OutputFlag=false)` or similar\n      (see the documentation for `MathProgBase`).\n\n\n\n\nAvailable strategies are:\n\n\n\n\n\"covariation\"\n: uses the Gaussian model and performs a matching on the scores (default).\n\n\n\"greedy\"\n: same as \n\"covariation\"\n but performs a greedy matching.\n\n\n\"random\"\n: produces a random matching, only useful to produce null models.\n\n\n\"genetic\"\n: tries to use the Uniprot ID information to determine which sequences belong to the\n\n\n\n\n       same operon (only used for testing, not a valid general strategy)\n\n\n\n\nsource\n\n\n#\n\n\nParalogMatching.write_fasta_match\n \n \nFunction\n.\n\n\nwrite_fasta_match(X12::HarmonizedAlignments, match::Vector{Int}, outfile::AbstractString)\n\n\n\n\nWrites a new FASTA file obtained from the two alignments contained in the \nX12\n object and the matching contained in \nmatch\n.\n\n\nThe sequences headers in the output file have the format \nID1::ID2/SPECIES\n, where \nID1\n represents the ID read from the first alignment, \nID2\n that for the second alignment, and \nSPECIES\n is the species name.\n\n\nThe new sequences in the output file are the concatenation of the matched sequences.\n\n\nsource\n\n\n\n\nCommand-line interface\n\n\nIn the \nutils\n directory there is a script which can be called from the command line, called \nparalog_matching.jl\n. Try calling it with:\n\n\n$ julia paralog_matching.jl --help\n\n\n\n\nto see the details. The arguments and options are basically the same as those of the \nparalog_matching\n function.", 
            "title": "Home"
        }, 
        {
            "location": "/#paralogmatchingjl-documentation", 
            "text": "", 
            "title": "ParalogMatching.jl documentation"
        }, 
        {
            "location": "/#introduction", 
            "text": "This package implements the paralog matching technique presented in the paper  \"Simultaneous identification of specifically interacting paralogs and interprotein contacts by Direct Coupling Analysis\"  by Thomas Gueudr\u00e9, Carlo Baldassi, Marco Zamparo, Martin Weigt and Andrea Pagnani, Proc. Natl. Acad. Sci. U.S.A. 201607570 (2016),  doi:10.1073/pnas.1607570113  The main idea of the method is to perform a statistical analysis of two given multiple sequence alignments, each containing one protein family. Each familiy should comprise several species, and each species may have several sequences belonging to the family. The algorithm tries to associate (match) interacting partners from the two families within each species.  The underlying main assumption is that the proper matching is the one maximizing the co-evolution signal. Such maximization is performed over the Bayesian inference of a Gaussian model, by inverting the correlation matrix.  The code is written in  Julia , and the functions are called from within Julia. However, a  command-line interface  is also provided for those unfamiliar with the language.  The current code was tested on Julia versions 0.4 and 0.5.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#installation", 
            "text": "To install the module, use this command from within Julia:  julia  Pkg.clone( https://github.com/Mirmu/ParalogMatching.jl )  Dependencies will be installed automatically.  However, you will also need to install at least one linear programming solver supported by  MathProgBase . See the list of available solvers at the  JuliaOpt page . Note that the solver efficiency is not particularly important for paralog matching, whose computational time is dominated by matrix inversion operations, therefore you don't need a particularly fast solver. If unsure, use  Pkg.add(\"Clp\")  or  Pkg.add(\"GLPKMathProgInterface\") , which are free and open-source solvers.", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "The module is loaded as any other Julia module:  julia  using ParalogMatching  The module provides a  high-level interface , with one function which performs all operations and writes a file in output, and the  low-level interface  functions which perform the single steps of the algorithm.  A typical run of the algorithm could look like this:  julia  TrpAB, match = paralog_matching( TrpA.fasta ,  TrpB.fasta ,  Match_TrpAB.fasta.gz , batch=5);", 
            "title": "Usage"
        }, 
        {
            "location": "/#high-level-interface", 
            "text": "#  ParalogMatching.paralog_matching     Function .  paralog_matching(infile1::AbstractString, infile2::AbstractString, outfile::AbstractString;\n         cutoff = 500,\n         batch = 1,\n         strategy =  covariation ,\n         lpsolver = nothing)  This function performs the paralog matching from two given FASTA files containing the alignments for two different protein families. When the matching is done, it writes the result in a new FASTA file, in which each sequence is the concatenation of two mathing sequences in the original file.  The input format is standard FASTA, but the headers are parsed as explained in  prepare_alignments .  The output file format is documented in  write_fasta_match .  The keyword arguments are documented in  prepare_alignments  and  run_matching .  Besides writing the  outfile , this function also returns two values: the harmonized alignment (produced by  prepare_alignments ) and the resulting match (as returned by  run_matching ).  source", 
            "title": "High-level interface"
        }, 
        {
            "location": "/#low-level-interface", 
            "text": "The low-level interface functions are called by  paralog_matching  in the order in which they are documented here, but they can be called individually in order to inspect/manipulate the intermediate results if desired.  #  ParalogMatching.read_fasta_alignment     Function .  read_fasta_alignment(filename, max_gap_fraction=1.0; header_regex=nothing)  Parse a (possibly gzipped) FASTA file, converting it into an alignment which can be used in the Gaussian model used by ParalogMatching. Optionally, discards the sequences which have more than a fraction  max_gap_fraction  of missing values (gaps) in the alignment.  The function automatically tries to parse the species names and the Uniprot ID, using a standard format specification. The species names are then used in the matching procedure; the Uniprot IDs are only used for writing the output files.  You can parse arbitrary files by providing a custom  header_regex  (see also the  Julia regex documentation ). In its simples form, it needs to have at least two capture groups, the first one returning the Uniprot ID and the second the species name (additional capture groups are ignored). For example, if the headers in your FASTA file look like this:  SOMELOCATION/SOMESPECIES/OTHERINFO  then you can use a regex like this one:  read_fasta_alignment(..., header_regex=r\"^([^/]+)/([^/]+)/\") , i.e. line start, anything except a slash (captured), followed by a slash, then anything except a slash (captured), then a slash \u2014 the remainder of the line is then simply ignored. In more complicated cases (e.g. if the UniprotID and the species name are out of order), you can use named capture groups: in this case the  header_regex  needs to contain both an  id  group and a  species  group (all additional groups are ignored). For example, if the headers in your FASTA file look like this:  SOMESPECIES/OTHERINFO/SOMELOCATION  then you can use a regex like this one:  header_regex=r\"^(? species [^/]+)/([^/]+)/(? id .+)\" , i.e. line start, anything except a slash (capture as the species name), followed by a slash, then anything except a slash (captured but ignored), followed by a slash, then the rest of the line (captured as the ID).  source  #  ParalogMatching.prepare_alignments     Function .  prepare_alignments(X1::Alignment, X2::Alignment; cutoff::Integer = 500)  Prepares two alignments (as returned by  read_fasta_alignment ) and returns a  HarmonizedAlignments  object. This object contains two filtered version of the original alignments, in which only the sequences belonging to species which exist in both alignments are kept, and which is ready to be passed to  run_matching .  The  cutoff  keyword argument can be used to discard all species for which there are more than a certain number of sequences in either alignment. Use  0  to disable this filter entirely.  source  #  ParalogMatching.run_matching     Function .  run_matching(X12::HarmonizedAlignments;\n     batch = 1,\n     strategy =  covariation ,\n     lpsolver = nothing)  Returns the matching of the two alignments contained in  X12 , which need to be obtained by  prepare_alignments . The returned matching is a Vector in which the entry  i  determines which sequence of the second alignment is the partner to sequence  i  in the first alignment.  The keywords are:   batch : how many species should be matched before updating the underlying model; smaller values give          better results but increase the computational time  strategy : the strategy to use when computing the matching. See below.  pseudo_count : gives the amount of regularization used for the inversion of the correlation matrix.                 A defaut of 0.5 gives sensible results, its value cannot be above 1.0.  lpsolver : linear programming solver used when performing the matching with the  \"covariation\"  strategy.         The default (`nothing`) uses the default solver as detected automatically by `MathProgBase`.\n      You can override this by passing e.g. `lpsolver = GurobiSolver(OutputFlag=false)` or similar\n      (see the documentation for `MathProgBase`).  Available strategies are:   \"covariation\" : uses the Gaussian model and performs a matching on the scores (default).  \"greedy\" : same as  \"covariation\"  but performs a greedy matching.  \"random\" : produces a random matching, only useful to produce null models.  \"genetic\" : tries to use the Uniprot ID information to determine which sequences belong to the          same operon (only used for testing, not a valid general strategy)  source  #  ParalogMatching.write_fasta_match     Function .  write_fasta_match(X12::HarmonizedAlignments, match::Vector{Int}, outfile::AbstractString)  Writes a new FASTA file obtained from the two alignments contained in the  X12  object and the matching contained in  match .  The sequences headers in the output file have the format  ID1::ID2/SPECIES , where  ID1  represents the ID read from the first alignment,  ID2  that for the second alignment, and  SPECIES  is the species name.  The new sequences in the output file are the concatenation of the matched sequences.  source", 
            "title": "Low-level interface"
        }, 
        {
            "location": "/#command-line-interface", 
            "text": "In the  utils  directory there is a script which can be called from the command line, called  paralog_matching.jl . Try calling it with:  $ julia paralog_matching.jl --help  to see the details. The arguments and options are basically the same as those of the  paralog_matching  function.", 
            "title": "Command-line interface"
        }
    ]
}