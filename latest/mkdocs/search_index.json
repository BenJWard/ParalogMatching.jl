{
    "docs": [
        {
            "location": "/", 
            "text": "ParalogMatching.jl documentation\n\n\n\n\nIntroduction\n\n\nThis module implements the paralog matching technique presented in the paper \nSimultaneous identification of specifically interacting paralogs and inter-protein contacts by Direct-Coupling Analysis\n by Thomas Gueudr\u00e9, Carlo Baldassi, Marco Zamparo, Martin Weigt and Andrea Pagnani.\n\n\nThe main idea of the method is to perform a statistical analysis of two given multiple sequence alignments, each containing one protein family. Each familiy should comprise several species, and each species may have several sequences belonging to the family. The algorithm tries to associate (match) interacting partners from the two families within each species.\n\n\nThe underlying main assumption is that the proper matching is the one maximizing the co-evolution signal. Such maximization is performed over the Bayesian inference of a Gaussian model, by inverting the correlation matrix.\n\n\nThe code is written in \nJulia\n, and the functions are called from within Julia. However, a \ncommand-line interface\n is also provided for those unfamiliar with the language.\n\n\nThe current code was tested on Julia versions 0.4 and 0.5.\n\n\n\n\nInstallation\n\n\nTo install the module, use this command from within Julia:\n\n\njulia\n Pkg.clone(\nhttps://github.com/Mirmu/ParalogMatching.jl\n)\n\n\n\n\nDependencies will be installed automatically.\n\n\nHowever, you will also need to install at least one linear programming solver supported by \nMathProgBase\n. See the list of available solvers at the \nJuliaOpt page\n. Note that the solver efficiency is not particularly important for paralog matching, whose computational time is dominated by matrix inversion operations, therefore you don't need a particularly fast solver. If unsure, use \nPkg.add(\"Clp\")\n or \nPkg.add(\"GLPKMathProgInterface\")\n, which are free and open-source solvers.\n\n\n\n\nUsage\n\n\nThe module is loaded as any other Julia module:\n\n\njulia\n using ParalogMatching\n\n\n\n\nThe module provides a \nhigh-level interface\n, with one function which performs all operations and writes a file in output, and the \nlow-level interface\n functions which perform the single steps of the algorithm.\n\n\nA typical run of the algorithm could look like this:\n\n\njulia\n TrpAB, match = paralog_matching(\nTrpA.fasta\n, \nTrpB.fasta\n, \nMatch_TrpAB.fasta.gz\n, batch=5);\n\n\n\n\n\n\nHigh-level interface\n\n\n#\n\n\nParalogMatching.paralog_matching\n \n \nFunction\n.\n\n\nparalog_matching(infile1::AbstractString, infile2::AbstractString, outfile::AbstractString;\n         cutoff = 500,\n         batch = 1,\n         strategy = \ncovariation\n,\n         lpsolver = nothing)\n\n\n\n\nThis function performs the paralog matching from two given FASTA files containing the alignments for two different protein families. When the matching is done, it writes the result in a new FASTA file, in which each sequence is the concatenation of two mathing sequences in the original file.\n\n\nThe input format is standard FASTA, but the headers are parsed as explained in \nprepare_alignments\n.\n\n\nThe output file format is documented in \nwrite_fasta_match\n.\n\n\nThe keyword arguments are documented in \nprepare_alignments\n and \nrun_matching\n.\n\n\nBesides writing the \noutfile\n, this function also returns two values: the harmonized alignment (produced by \nprepare_alignments\n) and the resulting match (as returned by \nrun_matching\n).\n\n\n\n\nLow-level interface\n\n\nThe low-level interface functions are called by \nparalog_matching\n in the order in which they are documented here, but they can be called individually in order to inspect/manipulate the intermediate results if desired.\n\n\n#\n\n\nParalogMatching.read_fasta_alignment\n \n \nFunction\n.\n\n\nread_fasta_alignment(filename, max_gap_fraction=1.0; header_regex=nothing)\n\n\n\n\nParse a (possibly gzipped) FASTA file, converting it into an alignment which can be used in the Gaussian model used by ParalogMatching. Optionally, discards the sequences which have more than a fraction \nmax_gap_fraction\n of missing values (gaps) in the alignment.\n\n\nThe function automatically tries to parse the species names and the Uniprot ID, using a standard format specification. The species names are then used in the matching procedure; the Uniprot IDs are only used for writing the output files.\n\n\nYou can parse arbitrary files by providing a custom \nheader_regex\n, which needs to have exactly two capture groups, the first one returning the Uniprot ID and the second the species name. For example, if the headers in your FASTA file look like this:\n\n\nSOMELOCATION/SOMESPECIES/OTHERINFO\n\n\n\n\nthen you can use a regex like this one: \nread_fasta_alignment(..., header_regex=r\"^([^/]+)/([^/]+)/\")\n, i.e. line start, anything except a slash (captured), followed by a slash, then anything except a slash (captured), then a slash \u2014 the remainder of the line is then simply ignored.\n\n\n#\n\n\nParalogMatching.prepare_alignments\n \n \nFunction\n.\n\n\nprepare_alignments(X1::Alignment, X2::Alignment; cutoff::Integer = 500)\n\n\n\n\nPrepares two alignments (as returned by \nread_fasta_alignment\n) and returns a \nHarmonizedAlignments\n object. This object contains two filtered version of the original alignments, in which only the sequences belonging to species which exist in both alignments are kept, and which is ready to be passed to \nrun_matching\n.\n\n\nThe \ncutoff\n keyword argument can be used to discard all species for which there are more than a certain number of sequences in either alignment. Use \n0\n to disable this filter entirely.\n\n\n#\n\n\nParalogMatching.run_matching\n \n \nFunction\n.\n\n\nrun_matching(X12::HarmonizedAlignments;\n     batch = 1,\n     strategy = \ncovariation\n,\n     lpsolver = nothing)\n\n\n\n\nReturns the matching of the two alignments contained in \nX12\n, which need to be obtained by \nprepare_alignments\n. The returned matching is a Vector in which the entry \ni\n determines which sequence of the second alignment is the partner to sequence \ni\n in the first alignment.\n\n\nThe keywords are:\n\n\n\n\n\n\nbatch\n: how many species should be matched before updating the underlying model; smaller values give            better results but increase the computational time\n\n\n\n\n\n\nstrategy\n: the strategy to use when computing the matching. See below.\n\n\n\n\n\n\npseudo_count\n: gives the amount of regularization used for the inversion of the correlation matrix.                   A defaut of 0.8 gives sensible results.\n\n\n\n\n\n\nlpsolver\n: linear programming solver used when performing the matching with the \n\"covariation\"\n strategy.        The default (\nnothing\n) uses the default solver as detected automatically by \nMathProgBase\n.        You can override this by passing e.g. \nlpsolver = GurobiSolver(OutputFlag=false)\n or similar        (see the documentation for \nMathProgBase\n).\n\n\n\n\n\n\nAvailable strategies are:\n\n\n\n\n\n\n\"covariation\"\n: uses the Gaussian model and performs a matching on the scores (default).\n\n\n\n\n\n\n\"greedy\"\n: same as \n\"covariation\"\n but performs a greedy matching.\n\n\n\n\n\n\n\"random\"\n: produces a rendom matching, only useful to produce null models.\n\n\n\n\n\n\n\"genetic\"\n: tries to use the Uniprot ID information to determine which sequences belong to the            same operon (only used for testing, not a valid general strategy)\n\n\n\n\n\n\n#\n\n\nParalogMatching.write_fasta_match\n \n \nFunction\n.\n\n\nwrite_fasta_match(X12::HarmonizedAlignments, match::Vector{Int}, outfile::AbstractString)\n\n\n\n\nWrites a new FASTA file obtained from the two alignments contained in the \nX12\n object and the matching contained in \nmatch\n.\n\n\nThe sequences headers in the output file have the format \nID1::ID2/SPECIES\n, where \nID1\n represents the ID read from the first alignment, \nID2\n that for the second alignment, and \nSPECIES\n is the species name.\n\n\nThe new sequences in the output file are the concatenation of the matched sequences.\n\n\n\n\nCommand-line interface\n\n\nIn the \nutils\n directory there is a script which can be called from the command line, called \nparalog_matching.jl\n. Try calling it with:\n\n\n$ julia paralog_matching.jl --help\n\n\n\n\nto see the details. The arguments and options are basically the same as those of the \nparalog_matching\n function.", 
            "title": "Home"
        }, 
        {
            "location": "/#paralogmatchingjl-documentation", 
            "text": "", 
            "title": "ParalogMatching.jl documentation"
        }, 
        {
            "location": "/#introduction", 
            "text": "This module implements the paralog matching technique presented in the paper  Simultaneous identification of specifically interacting paralogs and inter-protein contacts by Direct-Coupling Analysis  by Thomas Gueudr\u00e9, Carlo Baldassi, Marco Zamparo, Martin Weigt and Andrea Pagnani.  The main idea of the method is to perform a statistical analysis of two given multiple sequence alignments, each containing one protein family. Each familiy should comprise several species, and each species may have several sequences belonging to the family. The algorithm tries to associate (match) interacting partners from the two families within each species.  The underlying main assumption is that the proper matching is the one maximizing the co-evolution signal. Such maximization is performed over the Bayesian inference of a Gaussian model, by inverting the correlation matrix.  The code is written in  Julia , and the functions are called from within Julia. However, a  command-line interface  is also provided for those unfamiliar with the language.  The current code was tested on Julia versions 0.4 and 0.5.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#installation", 
            "text": "To install the module, use this command from within Julia:  julia  Pkg.clone( https://github.com/Mirmu/ParalogMatching.jl )  Dependencies will be installed automatically.  However, you will also need to install at least one linear programming solver supported by  MathProgBase . See the list of available solvers at the  JuliaOpt page . Note that the solver efficiency is not particularly important for paralog matching, whose computational time is dominated by matrix inversion operations, therefore you don't need a particularly fast solver. If unsure, use  Pkg.add(\"Clp\")  or  Pkg.add(\"GLPKMathProgInterface\") , which are free and open-source solvers.", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "The module is loaded as any other Julia module:  julia  using ParalogMatching  The module provides a  high-level interface , with one function which performs all operations and writes a file in output, and the  low-level interface  functions which perform the single steps of the algorithm.  A typical run of the algorithm could look like this:  julia  TrpAB, match = paralog_matching( TrpA.fasta ,  TrpB.fasta ,  Match_TrpAB.fasta.gz , batch=5);", 
            "title": "Usage"
        }, 
        {
            "location": "/#high-level-interface", 
            "text": "#  ParalogMatching.paralog_matching     Function .  paralog_matching(infile1::AbstractString, infile2::AbstractString, outfile::AbstractString;\n         cutoff = 500,\n         batch = 1,\n         strategy =  covariation ,\n         lpsolver = nothing)  This function performs the paralog matching from two given FASTA files containing the alignments for two different protein families. When the matching is done, it writes the result in a new FASTA file, in which each sequence is the concatenation of two mathing sequences in the original file.  The input format is standard FASTA, but the headers are parsed as explained in  prepare_alignments .  The output file format is documented in  write_fasta_match .  The keyword arguments are documented in  prepare_alignments  and  run_matching .  Besides writing the  outfile , this function also returns two values: the harmonized alignment (produced by  prepare_alignments ) and the resulting match (as returned by  run_matching ).", 
            "title": "High-level interface"
        }, 
        {
            "location": "/#low-level-interface", 
            "text": "The low-level interface functions are called by  paralog_matching  in the order in which they are documented here, but they can be called individually in order to inspect/manipulate the intermediate results if desired.  #  ParalogMatching.read_fasta_alignment     Function .  read_fasta_alignment(filename, max_gap_fraction=1.0; header_regex=nothing)  Parse a (possibly gzipped) FASTA file, converting it into an alignment which can be used in the Gaussian model used by ParalogMatching. Optionally, discards the sequences which have more than a fraction  max_gap_fraction  of missing values (gaps) in the alignment.  The function automatically tries to parse the species names and the Uniprot ID, using a standard format specification. The species names are then used in the matching procedure; the Uniprot IDs are only used for writing the output files.  You can parse arbitrary files by providing a custom  header_regex , which needs to have exactly two capture groups, the first one returning the Uniprot ID and the second the species name. For example, if the headers in your FASTA file look like this:  SOMELOCATION/SOMESPECIES/OTHERINFO  then you can use a regex like this one:  read_fasta_alignment(..., header_regex=r\"^([^/]+)/([^/]+)/\") , i.e. line start, anything except a slash (captured), followed by a slash, then anything except a slash (captured), then a slash \u2014 the remainder of the line is then simply ignored.  #  ParalogMatching.prepare_alignments     Function .  prepare_alignments(X1::Alignment, X2::Alignment; cutoff::Integer = 500)  Prepares two alignments (as returned by  read_fasta_alignment ) and returns a  HarmonizedAlignments  object. This object contains two filtered version of the original alignments, in which only the sequences belonging to species which exist in both alignments are kept, and which is ready to be passed to  run_matching .  The  cutoff  keyword argument can be used to discard all species for which there are more than a certain number of sequences in either alignment. Use  0  to disable this filter entirely.  #  ParalogMatching.run_matching     Function .  run_matching(X12::HarmonizedAlignments;\n     batch = 1,\n     strategy =  covariation ,\n     lpsolver = nothing)  Returns the matching of the two alignments contained in  X12 , which need to be obtained by  prepare_alignments . The returned matching is a Vector in which the entry  i  determines which sequence of the second alignment is the partner to sequence  i  in the first alignment.  The keywords are:    batch : how many species should be matched before updating the underlying model; smaller values give            better results but increase the computational time    strategy : the strategy to use when computing the matching. See below.    pseudo_count : gives the amount of regularization used for the inversion of the correlation matrix.                   A defaut of 0.8 gives sensible results.    lpsolver : linear programming solver used when performing the matching with the  \"covariation\"  strategy.        The default ( nothing ) uses the default solver as detected automatically by  MathProgBase .        You can override this by passing e.g.  lpsolver = GurobiSolver(OutputFlag=false)  or similar        (see the documentation for  MathProgBase ).    Available strategies are:    \"covariation\" : uses the Gaussian model and performs a matching on the scores (default).    \"greedy\" : same as  \"covariation\"  but performs a greedy matching.    \"random\" : produces a rendom matching, only useful to produce null models.    \"genetic\" : tries to use the Uniprot ID information to determine which sequences belong to the            same operon (only used for testing, not a valid general strategy)    #  ParalogMatching.write_fasta_match     Function .  write_fasta_match(X12::HarmonizedAlignments, match::Vector{Int}, outfile::AbstractString)  Writes a new FASTA file obtained from the two alignments contained in the  X12  object and the matching contained in  match .  The sequences headers in the output file have the format  ID1::ID2/SPECIES , where  ID1  represents the ID read from the first alignment,  ID2  that for the second alignment, and  SPECIES  is the species name.  The new sequences in the output file are the concatenation of the matched sequences.", 
            "title": "Low-level interface"
        }, 
        {
            "location": "/#command-line-interface", 
            "text": "In the  utils  directory there is a script which can be called from the command line, called  paralog_matching.jl . Try calling it with:  $ julia paralog_matching.jl --help  to see the details. The arguments and options are basically the same as those of the  paralog_matching  function.", 
            "title": "Command-line interface"
        }
    ]
}